# TS

js开发中的问题

- 使用了不存在的变量、函数或成员
- 把一个不确定类型，当做一个缺的定类型进行处理
- 使用null和undefined

js的原罪

- js语言本身特性，决定了该语言本身无法适应大型的复杂项目
- 弱类型: 某个变量可以随时更换类型
- 解释性: 错误发生的时间，是在运行时

前端开发中，大部分时间都是在排错

## TypeScript 简称TS

TypeScript是js的超集，是一个可选的、静态的类型系统

### 类型系统

    对代码中所有的标识符（变量、函数、参数、返回值）进行类型检查
    无论是浏览器还是Node环境都无法识别TS代码

> babel ES6 -> ES5

> 用tsc ts -> es    tsc: ts编译器

静态的含义就是类型检查，发生的时间是在编译的时候而不是在运行时

TS不参与任何运行时的类型检查

### TS惊喜

有了类型检查，增强了面向对象的开发

js也有类和对象，js支持面向对象开发，没有类型检查，很多面向对象的场景实现起来有诸多问题

使用TS后可以编写出完善的面向对象代码

## 安装TypeScript

> npm i typescript -g

默认情况下，TS会做出下面几种假设

- 假设当前执行环境为Dom
- 如果代码中没有使用模块化语句 import export, 便认为该代码为全局执行
- 编译的目标代码是ES3

有两种方式改变以上假设

- 使用tsc命令行时加上选项参数
- 使用ts配置文件更改编译选项

> tsc --init

### TS配置文件

配置文件使用后，使用tsc进行编译时不能跟上文件名，如果跟上文件名，会忽略配置文件

> @types/node

@types是TS官方的类型库，其中包含了很多对js代码的类型描述

> Jquery 没有类型检查 可以安装@types/jquery,为jquery库添加类型定义

> npm i @types/node -D

### 使用第三方库简化编译流程

> ts-node 将ts代码在内存中完成编译，同时完成运行

> nodemon 用户检测文件的变化

    nodemon --watch src  -e ts --exec ts-node src/index.ts

## 基本类型约束

TS是一个可选的静态类型系统

### 如何进行类型约束

> 变量、函数的参数、函数的返回值

### 源代码和编译结果的差异

编译结果中没有类型约束信息

### 基本类型

- number
- strint
- boolean
- array
- object
- null\undefined

null和undefined是所有其他类型的子类型，它们可以赋值给其他类型

通过添加```strictNullChecks: true```,可以获得更严格的空类型检查，null和undefined只能赋值给自身。

### 其他常用类型

- 联合类型：多种类型任选其一

配合类型保护进行判断

类型保护:当对某个变量进行类型判断之后，在判断的语句块中便可以确定它的确切类型
typeof可以出发类型保护

- void类型：通常用户约束函数的返回值，便是该函数灭有任何返回
- never类型：通常用户约束函数的返回值，表示该函数永远不可能结束
- 字面量类型：使用一个值进行约束
- 元祖类型(Tuple)：一个固定长度的数组，并且数组中每一项的类型确定
- any类型：any类型可以绕过类型检查，因此any类型的数据可以赋值给任意类型

### 类型别名

对已知的的一些类型定义名称

    type 类型名 = ...

### 函数的相关约束

函数重载：在函数实现之前，对函数调用的多种情况进行声明

可选参数：可以在某些参数名后加上问号，表示该参数可以不用传递，可选参数必须在参数列表的末尾

## 扩展类型-枚举

枚举通常用户约束某个变量的取值范围
字面量和联合类型配合使用，也可以达到同样的目标

```javascript
enum 枚举名 {
    枚举字段1 = 值,
    枚举字段2 = 值
}
```
- 枚举会出现编译结果中，编译结果中表现为对象
- 枚举的值可以是字符串或数字
- 数字枚举的值会自动自增
- 被数字枚举约束的变量可以直接赋值为数字
- 数字枚举的编译结果和字符串枚举有差异

最佳实践：

- 尽量不要在一个枚举中即出现字符串字段，又出现数字字段
- 使用枚举时尽量使用枚举字段的名称，不要使用真实的值

### 枚举的位运算

针对的数字枚举
位运算：两个数字换算成二进制后进行的运算
且运算：
异或：两个位置只要相同取0，不同取1

## 模块化

module 设置编译结果中使用的模块化标准
moduleResolution 设置解析模块的模式
noImplicitUseStrict 编译结果中不包含use strict
removeComments 编译结果移除注释
noEmitOnError 错误时不生成编译结果
esModuleInterop 启用es模块化交互非es模块导出

前端领域中模块化标准 es6 common.js amd umd system esnext

编译结果使用的是什么模块化标准?

### TS中如何书写模块化语句

TS中导入导出模块统一使用ES6的模块化标准

### 编译结果中的模块化

可配置的

























